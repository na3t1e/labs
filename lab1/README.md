# Работа 1: Разработка защищенного REST API с интеграцией в CI/CD

**Цель**: получить практический опыт разработки безопасного backend-приложения с автоматизированной проверкой кода на уязвимости. Освоить принципы защиты от OWASP Top 10 и интеграцию инструментов безопасности в процесс разработки.

*Выполнила*: `Андреева Анастасия`

*Группа*: `P3431`

## Эндпоинты API

1. **Регистрация пользователя**
- URL:  `POST /auth/register`
  *Регистрация нового пользователя*.
- Запрос:
```
{
  "username": "test",
  "password": "test"
  "nickname": "nickname",
  "email": "test@example.com"
}
```
- Ответ:
```
"User registered successfully"
```

2. **Логин пользователя**
- URL: `POST /auth/login`
  *Метод для аутентификации пользователя (принимает логин и пароль)*
- Запрос:
```
{
  "username": "test",
  "password": "test"
}
```
- Ответ: JWT-токен
```
{
  "token": "eyJhbGciOiJIUzI1NiJ9..."
}
```

3. **Получение данных**
- URL: `GET /api/data?username=test`
  *Метод для получения каких-либо данных (например, список пользователей или постов). Доступ должен быть только у аутентифицированных пользователей.*
- Ответ:
```
{
"example post"
}
```

4. **Создание заметки**
- URL: `POST /api/notes`
  *Метод для создания новой заметки текущего пользователя. Требуется аутентификация*
- Заголовки запроса:
```
Authorization: Bearer <токен_здесь>
Content-Type: application/json
```
- Запрос:
```
{
  "text": "Текст вашей заметки"
}
```

### Реализованные меры защиты

1.    **SQL Injection (SQLi):**
	- используется ORM (Hibernate/JPA) и параметризованные запросы, что исключает возможность внедрения SQL-кода. Spring Data JPA автоматически генерирует SQL за счет чего не конкатенируются строки и инъекция невозможна

2.    **XSS:**
	- сервер возвращает данные только в формате JSON, а не HTML; кроме того, Spring Security добавляет защитные HTTP-заголовки. API реализован как JSON-only (@RestController), сервер не рендерит HTML-страницы. Все ответы сериализуются Jackson’ом в JSON, а не вставляются в HTML-шаблоны;

3.    **Аутентификация и авторизация:**
	- реализованы с помощью JWT-токенов. Каждый запрос проверяется фильтром на наличие и корректность токена; неавторизованные запросы блокируются.

4.    **Пароли:**
	- сохраняются в базе данных только в хешированном виде (с помощью BCrypt). Bean PasswordEncoder создаёт BCrypt-хешер паролей для безопасного хранения и проверки. Пароли не хранятся в открытом виде, а проверяются через matches.

### Отчеты SAST/SCA

<img src=https://github.com/na3t1e/labs/blob/main/lab1/sucess.png/>

<img src=https://github.com/na3t1e/labs/blob/main/lab1/actions.png/>

<img src=https://github.com/na3t1e/labs/blob/main/lab1/otchot.png/>

[Ссылка](https://github.com/na3t1e/labs/actions/runs/20105308095/job/57687352018) на успешно пройденный pipeline

[Ссылка](https://github.com/na3t1e/labs)на GitHub репозиторий

### Вывод

В ходе выполнения данной лабораторной работы я вспомнила как работать со Spring Boot и использовать инструменты для разработки backend’а, защищенного от уязвимостей, такие как: JWT для безопасного управления сессиями пользователей, BCryptPasswordEncoder для безопасного хранения паролей, JPA/Hibernate для работы с базой данных с использованием параметризованных запросов и других.

Кроме того, я опробовала такие методы тестирования безопасности как SAST и SCA (через Snyk), которые подтвердили, что мой backend защищен от главных широко известных уязвимостей.



